#!/usr/bin/env python
"""
    %prog [options] config_file meds_file(s) out_file

Process the input meds file.
"""

import os,sys
from sys import stderr
import shutil
import numpy
import yaml
import fitsio
import meds
import gmix_meds
import pprint

import esutil as eu

from optparse import OptionParser
parser = OptionParser(__doc__)

parser.add_option("--obj-range",default=None,
                  help=("Inclusive, zero-offset range of objects to "
                        "process"))
parser.add_option("--det-cat", default=None,
                  help="detection cat for matched fluxes")

parser.add_option("--work-dir", default=None,
                  help=("copy files local for processing.  "
                        "Also write to local files and copy out."
                        "The local files are not removed."))

parser.add_option("--profile-image", default=None,
                  help=("Profile the code and create the specified "
                        "image using pycallgraph"))
def load_config(fname):
    with open(fname) as fobj:
        data=yaml.load(fobj)
    return data

def makedir_fromfile(fname):
    dname=os.path.dirname(fname)
    if not os.path.exists(dname):
        try:
            os.makedirs(dname)
        except:
            # probably a race condition
            pass

def make_ngmix_meta(conf, meds_meta_list, meds_files):

    dt = meds_meta_list[0].dtype.descr

    config_file=conf['config_file']

    clen=len(config_file)
    flen=max( [len(mf) for mf in meds_files] )


    dt += [('gmix_meds_config','S%d' % clen),
           ('meds_file','S%d' % flen)]

    nband=len(meds_meta_list)

    mlist=[]
    for band in xrange(nband):

        meta=numpy.zeros(1, dtype=dt)
        meds_file=meds_files[band]
        meds_meta=meds_meta_list[band]
        mf=meds_files[band]

        eu.numpy_util.copy_fields(meds_meta, meta)

        meta['gmix_meds_config'] = config_file
        meta['meds_file'] = meds_file

        mlist.append(meta)

    meta=eu.numpy_util.combine_arrlist(mlist)
    return meta


def make_lm_meta(conf, meds_meta_list, meds_files):

    dt = meds_meta_list[0].dtype.descr

    config_file=conf['config_file']

    clen=len(config_file)
    flen=max( [len(mf) for mf in meds_files] )
    mlen=len(conf['psf_model'])
    rlen=len(conf['region'])

    dt += [('gmix_meds_config','S%d' % clen),
           ('meds_file','S%d' % flen),
           ('psf_ntry','i2'),
           ('obj_ntry','i2'),
           ('psf_model','S%d' % mlen),
           ('psf_offset_max','f8'),
           ('region','S%d' % rlen)]

    nband=len(meds_meta_list)

    mlist=[]
    for band in xrange(nband):

        meta=numpy.zeros(1, dtype=dt)
        meds_file=meds_files[band]
        meds_meta=meds_meta_list[band]
        mf=meds_files[band]

        eu.numpy_util.copy_fields(meds_meta, meta)

        meta['gmix_meds_config'] = config_file
        meta['meds_file'] = meds_file
        meta['psf_ntry'] = conf['psf_ntry']
        meta['obj_ntry'] = conf['obj_ntry']
        meta['psf_model'] = conf['psf_model']
        meta['psf_offset_max'] = conf['psf_offset_max']
        meta['region'] = conf['region']
        mlist.append(meta)

    meta=eu.numpy_util.combine_arrlist(mlist)
    return meta

def make_mcmc_meta(conf, meds_meta, meds_file):

    raise ValueError("fix for multi-band")

    dt = meds_meta.dtype.descr

    config_file=conf['config_file']
    clen=len(config_file)
    flen=len(meds_file)
    mlen=len(conf['psf_model'])
    rlen=len(conf['region'])

    gtlen = len(conf['gprior_type'])

    dt += [('gmix_meds_config','S%d' % clen),
           ('meds_file','S%d' % flen),
           ('psf_ntry','i2'),

           ('nwalkers','i2'),
           ('burnin','i2'),
           ('nstep','i2'),
           ('mca_a','f8'),

           ('do_pqr','i2'),

           ('psf_model','S%d' % mlen),

           ('gprior_type','S%d' % gtlen),

           ('psf_offset_max','f8'),
           ('region','S%d' % rlen)]

    meta=numpy.zeros(1, dtype=dt)
    for n in meds_meta.dtype.names:
        meta[n] = meds_meta[n]

    meta['gmix_meds_config'] = config_file
    meta['meds_file'] = meds_file

    meta['psf_ntry'] = conf['psf_ntry']

    meta['nwalkers'] = conf['nwalkers']
    meta['burnin'] = conf['burnin']
    meta['nstep'] = conf['nstep']
    meta['mca_a'] = conf['mca_a']

    if conf['do_pqr']:
        meta['do_pqr']=1
    else:
        meta['do_pqr']=0

    meta['gprior_type'] = conf['gprior_type']

    meta['psf_model'] = conf['psf_model']
    meta['psf_offset_max'] = conf['psf_offset_max']
    meta['region'] = conf['region']

    return meta


def run_lm(meds_files, conf, checkpoint_data=None):
    gprior=get_g_prior(conf)
    conf['gprior'] = gprior

    if len(meds_files)==1:
        gm=gmix_meds.MedsFit(meds_files[0],
                             checkpoint_data=checkpoint_data,
                             **conf)
        gm.do_fits()
        data=gm.get_data()
        meds_meta=[gm.get_meds_meta()]
    else:
        gm=gmix_meds.MedsFitMB(meds_files,
                               checkpoint_data=checkpoint_data,
                               **conf)
        gm.do_fits()
        data=gm.get_data()
        meds_meta=gm.get_meds_meta_list()

    meta=make_lm_meta(conf, meds_meta, meds_files)

    return data, meta

def run_ngmix(meds_files, conf, checkpoint_data=None):
    import ngmix
    import gmix_meds.nfit

    
    conf['g_prior'] = get_g_prior_ngmix(conf)
    conf['cen_prior'] = get_cen_prior_ngmix(conf)
    conf['T_prior'] = get_T_prior_ngmix(conf)

    gm=gmix_meds.nfit.MedsFit(meds_files,
                             checkpoint_data=checkpoint_data,
                             **conf)
    gm.do_fits()
    data=gm.get_data()
    meds_meta=gm.get_meds_meta_list()


    meta=make_ngmix_meta(conf, meds_meta, meds_files)

    return data, meta

def get_T_prior_ngmix(conf):
    import ngmix

    T_prior_type=conf['T_prior_type']
    pars=conf['T_prior_pars']

    if T_prior_type == 'flat':
        T_prior=ngmix.priors.FlatPrior(pars[0], pars[1])
    elif T_prior_type=='lognormal':
        T_prior=ngmix.priors.LogNormal(pars[0], pars[1])
    else:
        raise ValueError("bad T prior type: %s" % T_prior_type)

    return T_prior

def get_g_prior_ngmix(conf):
    import ngmix
    if 'g_prior_type' in conf:
        g_prior_type=conf['g_prior_type']
    else:
        g_prior_type=None

    if g_prior_type is None or g_prior_type=='None':
        return None
    else:
        pars=conf['g_prior_pars']
        if g_prior_type=='exp':
            parr=numpy.array(pars,dtype='f8')
            return ngmix.priors.GPriorExp(parr)
        elif g_prior_type=='ba':
            return ngmix.priors.GPriorBA(pars)
        else:
            raise ValueError("implement gprior '%s'")

def get_cen_prior_ngmix(conf):
    import ngmix
    use_cen_prior=conf.get('use_cen_prior',False)
    if use_cen_prior:
        width=conf.get('cen_width',1.0)
        return ngmix.priors.CenPrior(0.0, 0.0, width,width)
    else:
        return None

def get_g_prior(conf):
    import gmix_image
    if 'g_prior_type' in conf:
        gprior_type=conf['g_prior_type']
    elif 'gprior_type' in conf:
        gprior_type=conf['gprior_type']
    else:
        gprior_type=None

    if gprior_type is None or gprior_type=='None':
        return None
    elif gprior_type =='flat':
        return gmix_image.priors.GPriorFlat()
    elif gprior_type=='exp':
        pars=conf['gprior_pars']
        return gmix_image.priors.GPriorExp(pars)
    else:
        raise ValueError("implement gprior '%s'")

def run_mcmc(meds_files, conf):
    gprior=get_g_prior(conf)

    if len(meds_files)==1:
        gm=gmix_meds.MedsMCMC(meds_files[0], gprior, **conf)
    else:
        raise ValueError("implement mb for mcmc")

    gm.do_fits()

    data=gm.get_data()
    meds_meta=gm.get_meds_meta()
    meta=make_mcmc_meta(conf, meds_meta, meds_files[0])

    return data, meta


def reroot_file(fname, newdir):
    bname=os.path.basename(fname)
    return os.path.join(newdir, bname)

class WorkFiles(object):
    def __init__(self, work_dir, flist, mode='r'):
        self.work_dir=work_dir
        self.mode=mode

        if not os.path.exists(work_dir):
            os.makedirs(work_dir)

        self.init(flist)

    def __enter__(self):
        return self

    def __exit__(self, exception_type, exception_value, traceback):
        self.close()

    def init(self, flist):
        """
        remote files we copy local temporarily.
        """

        self.remote_files=self.as_string_list(flist)

        self.local_files=[]
        for remote_file in self.remote_files:
            local_file=reroot_file(remote_file, self.work_dir)
            self.local_files.append(local_file)

            if self.mode=='r':
                print >>stderr,'%s -> %s' % (remote_file,local_file)
                shutil.copy2(remote_file, local_file)


    def close(self):
        """

        If reading, remove the files we copied locally, or copy remote if we
        were writing

        """
        try:
            if self.mode=='w':
                self.copy_to_remote()
        finally:
            for local_file in self.local_files:
                print >>stderr,'removing local file:',local_file
                os.remove(local_file)


    def copy_to_remote(self):
        """
        If mode is 'w', we copy the local files to their
        destination
        """
        if self.mode=='r':
            return

        for i in xrange(len(self.local_files)):
            local_file=self.local_files[i]
            remote_file=self.remote_files[i]

            print >>stderr,'%s -> %s' % (local_file,remote_file)
            shutil.copy2(local_file, remote_file)

    def as_string_list(self, data):
        if isinstance(data, basestring):
            out_data=[data]
        else:
            if not isinstance(data, (list,tuple)):
                raise ValueError("input must be string or seq of strings")
            for s in data:
                if not isinstance(s, basestring):
                    raise ValueError("input must be string or seq of strings")
            out_data=list(data)

        return out_data

def get_sub_fname(fname, rng, work_dir):
    rng_string = '%s-%s' % (rng[0], rng[1])

    bname = os.path.basename(fname)

    bname = bname.replace('.fits.fz','').replace('.fits','')
    bname = '%s-%s.fits' % (bname, rng_string)

    newf = os.path.join(work_dir, bname)

    return newf

def get_sub(meds_files, rng, work_dir):
    """
    Local files will get cleaned up
    """
    extracted=[]

    for f in meds_files:

        print >>stderr,f
        newf = get_sub_fname(f, rng, work_dir)
        ex=meds.MEDSExtractor(f, rng[0], rng[1], newf, cleanup=True)
        extracted.append(ex)

    return extracted

def get_range(rng_string):
    if rng_string is not None:
        rng = rng_string.split(',')
        rng = [int(i) for i in rng]
    else:
        rng=None

    return rng

def go_profile(config_file, meds_files, out_file, options, img_name):
    conf=load_config(config_file)
    if conf['fitter']=='ngmix':
        # pycallgraph doesn't like it when the JIT starts up
        import ngmix

    import pycallgraph
    from pycallgraph import PyCallGraph
    from pycallgraph.output import GraphvizOutput

    graphviz = GraphvizOutput()
    print 'profile image:',img_name
    graphviz.output_file = img_name
    config=pycallgraph.Config(groups=False)

    with PyCallGraph(config=config, output=graphviz):
        go(config_file, meds_files, out_file, options)

def go(config_file, meds_files, out_file, options):

    checkpoint_file=out_file.replace('.fits','-checkpoint.fits')
    if os.path.exists(checkpoint_file):
        print >>stderr,'reading checkpoint data:',checkpoint_file
        checkpoint_data=fitsio.read(checkpoint_file,extname='model_fits')
    else:
        checkpoint_data=None

    conf=load_config(config_file)
    pprint.pprint(conf,stream=stderr)

    rng=get_range( options.obj_range )
    rng_send=None
    if rng is not None:
        if options.work_dir is not None:
            # note extracted get cleaned up when MedsExtractors
            # get garbage collected
            extracted=get_sub(meds_files, rng, options.work_dir)
            meds_files_full=meds_files
            meds_files=[ex.sub_file for ex in extracted]
            rng_send=None
        else:
            rng_send=rng


    det_cat_file=options.det_cat
    if det_cat_file is not None and det_cat_file != "":
        print >>stderr,'reading:',det_cat_file
        det_cat=fitsio.read(det_cat_file)
    else:
        det_cat=None

    # we now do range by extracting it, see above, so
    # this is always None
    conf['obj_range'] = rng_send
    conf['det_cat'] = det_cat
    conf['config_file']=config_file
    conf['checkpoint_file']=checkpoint_file

    if conf['fitter'] == 'lm':
        data, meta = run_lm(meds_files, conf,
                            checkpoint_data=checkpoint_data)
    elif conf['fitter'] == 'ngmix':
        data, meta = run_ngmix(meds_files, conf,
                               checkpoint_data=checkpoint_data)
    else:
        data, meta = run_mcmc(meds_files, conf,
                              checkpoint_data=checkpoint_data)

    if options.work_dir is not None:
        meta['meds_file'] = meds_files_full


    makedir_fromfile(out_file)
    print >>stderr,'writing:',out_file
    with fitsio.FITS(out_file,'rw',clobber=True) as fobj:
        fobj.write(data,extname="model_fits")
        fobj.write(meta,extname="meta_data")

    # if we get here, we have succeeded in writing the data
    # we can remove the checkpoint file
    if os.path.exists(checkpoint_file):
        print >>stderr,'removing checkpoint file',checkpoint_file
        os.remove(checkpoint_file)

def go_local_old(config_file, meds_files, out_file, options):
    """
    copying full files local
    """
    with WorkFiles(options.work_dir, meds_files, mode='r') as rf:
        with WorkFiles(options.work_dir, [out_file], mode='w') as wf:
            meds_local=rf.local_files
            out_local = wf.local_files[0]
            go(config_file, meds_local, out_local, options)

    
def main():
    options, args = parser.parse_args(sys.argv[1:])
    if len(args) < 3:
        parser.print_help()
        sys.exit(45)

    config_file=args[0]
    meds_files=args[1].split(',')
    out_file=args[2]

    if options.profile_image is not None:
        go_profile(config_file, meds_files, out_file, options,
                   options.profile_image)
    else:
        go(config_file, meds_files, out_file, options)
    """
    if options.work_dir is not None:
        go_local(config_file, meds_files, out_file, options)
    else:
        go(config_file, meds_files, out_file, options)
    """

main()
